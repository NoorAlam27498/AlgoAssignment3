Solutions Guide for Assignment 3: Analysis of Iterative Algorithms

To solve this task, follow these steps systematically:

Step 1: Setup Development Environment
- Choose a programming language you are comfortable with (e.g., Python, C++, Java).
- Ensure you have access to required libraries or tools for execution time measurement.

Step 2: Implement Sorting Algorithms
- Implement each of the following sorting algorithms:
  1. Insertion Sort
  2. Bubble Sort
  3. Merge Sort
  4. Heap Sort
  5. Quick Sort
  6. Counting Sort
  7. Radix Sort
  8. Bucket Sort

Step 3: Input Data
- Load the dataset provided in data.csv.
- Ensure the data is properly read and converted into a list/array suitable for sorting.

Step 4: Time Complexity Analysis
- Write the theoretical time complexity for each algorithm:
  - Insertion Sort: O(n^2)
  - Bubble Sort: O(n^2)
  - Merge Sort: O(n log n)
  - Heap Sort: O(n log n)
  - Quick Sort: O(n log n) on average, O(n^2) worst case
  - Counting Sort: O(n + k)
  - Radix Sort: O(nk)
  - Bucket Sort: O(n + k)

Step 5: Empirical Testing
- Run each algorithm on the dataset.
- Measure execution time in milliseconds using built-in timers (e.g., time.time() in Python, chrono in C++).

Step 6: Documentation of Results
- Create a table with the following fields:
  Algorithm | Theoretical/Algorithmic Time Complexity | Execution Time (ms)

Step 7: Include Code
- For each algorithm, include the implementation code clearly with comments for explanation.

Step 8: Prepare Final Report
- Summarize observations on performance differences between algorithms.
- Explain why certain algorithms perform better depending on input size and nature of data.

By following these steps, you will complete the assignment with both theoretical and experimental insights into sorting algorithms.
